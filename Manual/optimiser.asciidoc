:stem: latexmath
:sectnums:
:toc: macro
:toclevels: 3

link:home[Back to Main Page]

toc::[]

[[chp:moo]]
Multi Objective Optimisation
----------------------------

Optimization methods deal with finding a feasible set of solutions
corresponding to extreme values of some specific criteria. Problems
consisting of more than one criterion are called _multi-objective
optimization problems_. Multiple objectives arise naturally in many real
world optimization problems, such as portfolio optimization, design,
planning and many more [pgnl:06,zepv:00,gala:98,yrss:09,basi:05]. It is
important to stress that multi-objective problems are in general harder
and more expensive to solve than single-objective optimization problems.

In this chapter we introduce multi-objective optimization problems and
discuss techniques for their solution with an emphasis on evolutionary
algorithms.

NOTE: For multi-objective optimization OPAL uses https://gitlab.psi.ch/OPAL/opt-pilot/[`opt-pilot`] developed by Y. Ineichen. `opt-pilot` has been fully integrated into OPAL. Instructions can be found on the https://gitlab.psi.ch/OPAL/opt-pilot/wikis/home[`opt-pilot` wiki page].

[[definition]]
Definition
~~~~~~~~~~

As with single-objective optimization problems, multi-object
optimization problems consist of a solution vector and optionally a
number of equality and inequality constraints. Formally, a general
multi-objective optimization problem has the form

[[eq:moop:obj]]
[[eq:moop:constr]]
[[eq:moop:dvar]]
[latexmath]
++++
\begin{aligned}
  \mathrm{min}  \quad & \quad f_m(\mathbf{x}),        & m &= \{1, \ldots, M\} \\
  \mathrm{s.t.} \quad & \quad g_j(\mathbf{x}) \geq 0, & j &= \{1, \ldots, J\} \\
  \quad & \quad  -\infty \leq x_i^L \leq \mathbf{x}=x_i \leq x_i^U \leq \infty,& i &= \{0, \ldots, n \}.
\end{aligned}
++++

The latexmath:[M]
objectives ([eq:moop:obj]) are minimized, subject to latexmath:[J]
inequality constraints ([eq:moop:constr]). An latexmath:[n]-vector
([eq:moop:dvar]) contains all the design variables with appropriate
lower and upper bounds, constraining the design space.

In contrast to single-objective optimization the objective functions
span a multi-dimensional space in addition to the design variable space
– for each point in design space there exists a point in objective
space. The mapping from the latexmath:[n] dimensional design space to
the latexmath:[M] dimensional objective space visualized in
Figure <<fig:des_to_obj,1>> is often non-linear. This impedes the search for
optimal solutions and increases the computational cost as a result of
expensive objective function evaluation. Additionally, depending in
which of the two spaces the algorithm uses to determine the next step,
it can be difficult to assure an even sampling of both spaces
simultaneously.

[#fig:des_to_obj]
.Figure 1: The (often non-linear) mapping latexmath:[f : \mathbb{R}^n \rightarrow \mathbb{R}^M] from design to objective space. The dashed lines represent the constraints in design space and the set of solutions (Pareto front) in objective space.
image:figures/optimiser/design_objective_space.png[]

A special subset of multi-objective optimization problems where all
objectives and constraints are linear, called _Multi-objective linear
programs_, exhibit formidable theoretical properties that facilitate
convergence proofs. In this thesis we strive to address arbitrary
multi-objective optimization problems with non-linear constraints and
objectives. No general convergence proofs are readily available for
these cases.

[[pareto-optimality]]
Pareto Optimality
~~~~~~~~~~~~~~~~~

In most multi-objective optimization problems we have to deal with
conflicting objectives. Two objectives are conflicting if they possess
different minima. If all the mimima of all objectives coincide the
multi-objective optimization problem has only one solution. To
facilitate comparing solutions we define a partial ordering relation on
candidate solutions based on the concept of dominance. A solution is
said to dominate another solution if it is no worse than the other
solution in all objectives and if it is strictly better in at least one
objective. A more formal description of the dominance relation is given
in [deb:09].

The properties of the dominance relation include transitivity

[latexmath]
++++
x_1 \preceq x_2 \wedge x_2 \preceq x_3 \Rightarrow x_1 \preceq x_3 ,
++++

and asymmetricity, which is necessary for an unambiguous order relation

[latexmath]
++++
x_1 \preceq x_2 \Rightarrow x_2 \npreceq x_1 .
++++

Using the concept of dominance, the sought-after set of Pareto optimal
solution points can be approximated iteratively as the set of
non-dominated solutions.

The problem of deciding if a point truly belongs to the Pareto set is
NP-hard. As shown in Figure <<fig:pareto-def,2>> there exist "weaker"
formulations of Pareto optimality. Of special interest is the result
shown in [paya:01], where the authors present a polynomial (in the input
size of the problem and latexmath:[1/\varepsilon]) algorithm for
finding an approximation, with accuracy latexmath:[\varepsilon], of
the Pareto set for database queries.

[fig:pareto-def]
.Figure 2: Various definitions regarding Pareto optimality.
image:figures/optimiser/pareto-defs.png[]

[[opt-pilot-commands]]
OPAL Commands
~~~~~~~~~~~~~

Basic Syntax
^^^^^^^^^^^^

One needs to define the design variables, objectives and constraints one by one:

```
d1: DVAR, VARIABLE="x1", LOWERBOUND="-1.0", UPPERBOUND="1.0";
d2: DVAR, VARIABLE="x2", LOWERBOUND="-1.0", UPPERBOUND="1.0";
d3: DVAR, VARIABLE="x3", LOWERBOUND="-1.0", UPPERBOUND="1.0";
```

This defines three design variables named `d1`, `d2` and `d3`.
The variable names `x1`, `x2` and `x3` can be used in objectives and constraints.
Bounds for design variables should always be given. Note the string notation.

```
obj1: OBJECTIVE, EXPR="-energy";
obj2: OBJECTIVE, EXPR="emit_x";
```

This defines two objectives named `obj1` and `obj2`.
The optimiser knows several mathematical functions and methods to access output files (see below).
Without the use of these special methods design variables or the variables from the `.stat` output file at the end of the simulation can be used for optimisation.
Note that objectives are always minimised, so in this case a solution where the final energy is maximal and the final horizontal emittance is minimal is looked for.

```
con1: CONSTRAINT, EXPR="x1+x2<1.0";
con2: CONSTRAINT, EXPR="numParticles>1000";
```

This defines two constraints. The syntax is similar to the `OBJECTIVE` syntax.
The first constraint consists of only design variables and will be evaluated before the simulation.
The second constraint will be evaluated after the simulation.

After defining the individual elements, one needs to define the sets of design variables, objectives and constraints:

```
dvars:   DVARS       = (d1, d2, d3);
objs:    OBJECTIVES  = (obj1, obj2);
constrs: CONSTRAINTS = (con1, con2);
```

Zero constraints can be defined as:

```
constrs: CONSTRAINTS = ();
```

Finally, the optimiser command should be added:

```
opt: OPTIMIZE, OBJECTIVES=objs, DVARS=dvars, CONSTRAINTS=constrs;
```

OPTIMIZE Command
^^^^^^^^^^^^^^^^^
The OPTIMIZE command initiates optimization.

[#optcommandattributes]
.Attributes for the command OPTIMIZE.
[cols="<1,<5",options="header",]
|=======================================================================
|Attribute |Description
| INPUT |  Path to input file.
| OUTPUT |  Name used in output file generation.
| OUTDIR |  Name of directory used to store generation output files.
| OBJECTIVES |  List of objectives to be used.
| DVARS |  List of optimization variables to be used.
| CONSTRAINTS |  List of constraints to be used.
| INITIALPOPULATION |  Size of the initial population.
| NUM_MASTERS |  Number of master nodes.
| NUM_COWORKERS |  Number processors per worker.
| SELECTOR |  Path of the selector.
| DUMP_DAT |  Dump old generation data format with frequency.
| DUMP_FREQ |  Dump old generation data format with frequency.
| NUM_IND_GEN |  Number of individuals in a generation.
| MAXGENERATIONS |  Number of generations to run.
| EPSILON |  Tolerance of hypervolume criteria.
| EXPECTED_HYPERVOL |  The reference hypervolume.
| CONV_HVOL_PROG |  converge if change in hypervolume is smaller.
| ONE_PILOT_CONVERGE | 
| SOL_SYNCH |  Solution exchange frequency.
| GENE_MUTATION_PROBABILITY |  Mutation probability of individual gene, default: 0.5.
| MUTATION_PROBABILITY |  Mutation probability of genom, default: 0.5.
| RECOMBINATION_PROBABILITY |  Probability for genes to recombine, default: 0.5.
| SIMBIN_CROSSOVER_NU |  Simulated binary crossover.
| SIMTMPDIR |  Directory where simulations are run.
| TEMPLATEDIR |  Directory where templates are stored.
| FIELDMAPDIR |  Directory where field maps are stored.
|=======================================================================

DVAR Command
^^^^^^^^^^^^
The DVAR command defines a variable for optimization.

[#dvarcommandattributes]
.Attributes for the command DVAR.
[cols="<1,<5",options="header",]
|=======================================================================
|Attribute   | Description
| VARIABLE   | Variable name that should be varied during optimization.
| LOWERBOUND | Lower limit of the range of values that the variable should assume.
| UPPERBOUND | Upper limit of the range of values that the variable should assume.
|=======================================================================

OBJECTIVE Command
^^^^^^^^^^^^^^^^^
The OBJECTIVE command defines an objective for optimization.

[#objectivecommandattributes]
.Attributes for the command OBJECTIVE.
[cols="<1,<5",options="header",]
|=======================================================================
|Attribute |Description
| EXPR | Expression to minimize during optimization.
|=======================================================================

CONSTRAINT Command
^^^^^^^^^^^^^^^^^
The CONSTRAINT command defines a constraint for optimization.

[#constraintcommandattributes]
.Attributes for the command CONSTRAINT.
[cols="<1,<5",options="header",]
|=======================================================================
|Attribute |Description
| EXPR | Expression that should be fulfilled during optimization.
|=======================================================================


Available Expressions
^^^^^^^^^^^^^^^^^^^^^
[#availableexpressions]
.Available functions for the EXPR attributes for OBJECTIVE and CONSTRAINT.
[cols="<3,<5",options="header",]
|=======================================================================
| Function         | Description
| fromFile(<file>) | Simple functor that reads vector data from a file. If the file contains more than one value the sum is returned.
| sddsVariableAt(<var>, <spos>, <sdds_file>)     | A simple expression to get SDDS value near a specific spos for a variable.
| sameSDDSVariableAt(<var>, <spos>)              | The same as `sddsVariableAt`, uses OPALs statistics file.
| sumErrSq(<meas_file>, <var_name>, <sdds_file>) | A simple expression computing the sum of all measurement errors (given as first and third argument) for a variable (second argument) according to
latexmath:[result = \frac{1}{n} * \sqrt{\sum_{i=0}^n (measurement_i - value_i)^2}]
| radialPeak(<file>, <turn>)                     | A simple expression to get the n-th peak of a radial probe https://gitlab.psi.ch/AMAS-BDModels/PSI-Ring/blob/master/RawData/RRI2-0038Y17.peaks[file].
| sumErrSqRadialPeak(<meas_file>, <sim_file>, <begin>, <end>) | A simple expression computing the sum of all peak errors (given as first and second argument) for a range of peaks (third argument and fourth argument)
latexmath:[result = \frac{1}{n} * \sqrt{\sum_{i=start}^{end} (measurement_i - value_i)^2}]
| probVariableWithID(<var>, <id>, <probe_file>)  | Returns the value of the variable (first argument) with a certain ID (second argument) from link:elements#probe-opal-cycl[probe] loss file (third argument).
|=======================================================================

Example Input File
^^^^^^^^^^^^^^^^^^
Example input file for the optimization using the template _05-DL_QN3.tmpl_:
....
OPTION, ECHO=FALSE;
OPTION, INFO=TRUE;

TITLE, STRING="OPAL Test MAB, 2016-10-13";

REAL up = 0.0000977;
REAL loc = 2.0;

dv0: DVAR, VARIABLE="QDX1_K1", LOWERBOUND=0, UPPERBOUND=35;
dv1: DVAR, VARIABLE="QDX2_K1", LOWERBOUND=0, UPPERBOUND=34;
dv2: DVAR, VARIABLE="QFX1_K1", LOWERBOUND=-35, UPPERBOUND=0;

drmsx:   OBJECTIVE, EXPR="fabs(sameSDDSVariableAt('rms_x',${loc}) - ${up})";
drmsy:   OBJECTIVE, EXPR="fabs(sameSDDSVariableAt('rms_y',${loc}) - 0.0001833)";
goalfun: OBJECTIVE, EXPR="sameSDDSVariableAt('rms_x',2.00)";

OPTIMIZE, INPUT="tmpl/05-DL_QN3.tmpl", OBJECTIVES = {drmsx, drmsy, goalfun}, 
          DVARS = {dv0, dv1, dv2}, INITIALPOPULATION=50, MAXGENERATIONS=50, 
          NUM_IND_GEN=50, MUTATION_PROBABILITY=0.43, SIMBIN_CROSSOVER_NU=2.0, 
          NUM_MASTERS=1, NUM_COWORKERS=1, SIMTMPDIR="simtmpdir", TEMPLATEDIR="tmpl", 
          FIELDMAPDIR="fieldmaps", OUTPUT="optLinac", OUTDIR="results";

QUIT;
....

Template file _05-DL_QN3.tmpl_:
....
OPTION, ECHO=FALSE;
OPTION, INFO=FALSE;
OPTION, PSDUMPFREQ=1000000;
OPTION, STATDUMPFREQ=20;
OPTION, CZERO=TRUE;
OPTION, IDEALIZED=TRUE;
OPTION, VERSION=10900;

TITLE, STRING="OPAL Test MAB, 2016-10-13";

//////////////////////////////                                                                                                                                                                                                                 
// Begin Content                                                                                                                                                                                                                               
//////////////////////////////                                                                                                                                                                                                                 

REAL SOL  = 2.9979246E8;
REAL Pcen = 100.0E6;
REAL BRho = Pcen/SOL;
REAL QK1  = 6.2519;
REAL QSTR = QK1*BRho/2.0;

QDX1: QUADRUPOLE, ELEMEDGE=0.0, L=0.10, APERTURE="circle(0.1)", K1=_QDX1_K1_ * BRho / 2;
QFX1: QUADRUPOLE, ELEMEDGE=0.91, L=0.20, APERTURE="circle(0.1)", 
                  K1=_QFX1_K1_ * BRho / 2;
QDX2: QUADRUPOLE, ELEMEDGE=1.92, L=0.10, APERTURE="circle(0.1)", 
                  K1=_QDX2_K1_ * BRho / 2;

FODO: LINE = (QDX1, QFX1, QDX2);

//////////////////////////////                                                                                                                                                                                                                 
// Begin Summary                                                                                                                                                                                                                               
//////////////////////////////                                                                                                                                                                                                                 

FODO_Full: LINE = (FODO), ORIGIN={0,0,0}, ORIENTATION={0.0, 0.0, 0.0};

//////////////////////////////                                                                                                                                                                                                                 
// End Summary                                                                                                                                                                                                                                 
//////////////////////////////                                                                                                                                                                                                                 

// SC calculations on:                                                                                                                                                                                                                         
Fs1:FIELDSOLVER, FSTYPE = FFT, MX = 16, MY = 16, MT = 16,
                  PARFFTX = true, PARFFTY = true, PARFFTT = true,
                  BCFFTX = open, BCFFTY = open, BCFFTT = open,
                  BBOXINCR = 1, GREENSF = INTEGRATED;
Fs2:FIELDSOLVER, FSTYPE = NONE, MX = 16, MY = 16, MT = 16,
                 PARFFTX = true, PARFFTY = true, PARFFTT = true,
                 BCFFTX = open, BCFFTY = open, BCFFTT = open,
                 BBOXINCR = 1, GREENSF = INTEGRATED;


Dist2: DISTRIBUTION, TYPE="FROMFILE", FNAME="fodo_opal.in";


REAL MINSTEPFORREBIN = 500;

REAL qb=77.0e-12;
REAL bfreq=1300.0E6;
REAL bcurrent=qb*bfreq;

beam1: BEAM, PARTICLE = ELECTRON, pc = P0, NPART = 5000, BFREQ = bfreq, BCURRENT = bcurrent, CHARGE = -1;

SELECT, LINE=FODO_Full;

TRACK, LINE=FODO_Full, BEAM=beam1, MAXSTEPS={6e5}, DT={1e-12}, ZSTOP={2.02};

RUN, METHOD = "PARALLEL-T", BEAM = beam1, FIELDSOLVER = Fs2, DISTRIBUTION = Dist2;

ENDTRACK;

QUIT;
....
